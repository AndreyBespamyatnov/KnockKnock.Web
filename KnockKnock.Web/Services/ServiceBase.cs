using System;
using System.Diagnostics;
using System.Runtime.Caching;

namespace KnockKnock.Web.Services
{
    /// <summary>
    /// The base service class, provide helper methods for caching and logging exceptions
    /// </summary>
    public abstract class ServiceBase
    {
        protected int CacheExpireInMiuts = 60;

        /// <summary>
        /// Put <see cref="T"/> value to memory cache
        /// <remarks>
        /// Key will be autogenerated based on <see cref="T"/> type, using <b>nameof</b> operator
        /// </remarks>
        /// </summary>
        /// <typeparam name="T">Type of object to store to cache</typeparam>
        /// <param name="value">The value to store</param>
        /// <param name="key">The key for cache value, if null value used as key</param>
        protected void AddToCache<T>(T value, string key = null)
        {
            try
            {
                key = key == null ? $"{typeof(T).Name}{value}" : $"{key}{value}";
                var cacheItemPolicy = new CacheItemPolicy {SlidingExpiration = TimeSpan.FromMinutes(CacheExpireInMiuts)};
                MemoryCache.Default.Add(key, value, cacheItemPolicy);
            }
            catch (Exception ex)
            {
                LogErrorException(ex);
#if DEBUG
                if (Debugger.IsAttached)
                {
                    Debug.WriteLine(ex.Message);
                    Debugger.Break();
                }
#endif
            }
        }

        /// <summary>
        /// Safety get from cache by key
        /// <remarks>
        /// To key will be apper prefix with type of <see cref="T"/>
        /// </remarks>
        /// </summary>
        /// <typeparam name="T">Type of object to retrive from cache</typeparam>
        /// <param name="key">The key to retrive</param>
        /// <param name="dafaultValue">The default value if need, by default is default(T)<b></b></param>
        /// <returns>Cached value with type of <see cref="T"/></returns>
        protected T GetFromCache<T>(T key, T dafaultValue = default(T))
        {
            return GetFromCache(key.ToString(), dafaultValue);
        }

        /// <summary>
        /// Safety get from cache by key
        /// <remarks>
        /// To key will be apper prefix with type of <see cref="T"/>
        /// </remarks>
        /// </summary>
        /// <typeparam name="T">Type of object to retrive from cache</typeparam>
        /// <param name="key">The key to retrive</param>
        /// <param name="dafaultValue">The default value if need, by default is default(T)<b></b></param>
        /// <returns>Cached value with type of <see cref="T"/></returns>
        protected T GetFromCache<T>(string key, T dafaultValue = default(T))
        {
            try
            {
                var fullKey = $"{typeof(T).Name}{key}";
                var cacheItem = MemoryCache.Default.GetCacheItem(fullKey);
                var conversionType = typeof(T);
                if (CanChangeType(cacheItem, conversionType))
                {
                    dafaultValue = (T)Convert.ChangeType(cacheItem, conversionType);
                }
            }
            catch (Exception ex)
            {
                LogErrorException(ex);
#if DEBUG
                if (Debugger.IsAttached)
                {
                    Debug.WriteLine(ex.Message);
                    Debugger.Break();
                }
#endif
            }

            return dafaultValue;
        }     

        /// <summary>
        /// Log exception to default logger system
        /// </summary>
        /// <param name="ex">Exception to log</param>
        protected void LogErrorException(Exception ex)
        {
            Logger.Instance.LogError(ex);
        }

        private static bool CanChangeType(object value, Type conversionType)
        {
            if (conversionType == null)
            {
                return false;
            }

            IConvertible convertible = value as IConvertible;
            return convertible != null;
        }
    }
}